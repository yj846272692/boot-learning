# 03.10-Restful实现和测试

## Restful实现和测试

## 2-RESTful接口实现与测试

### 2.1 RESTful接口与http协议状态表述

#### 一、RESTful风格API的好处

API (Application Programming Interface),顾名思义:是一组编程接口规范,客户端与服务端通过请求响应进行数据通信.REST(Representational State Transfer）表述性状态传递,决定了接口的形式与规则.**RESTful是基于http方法的APl设计风格,而不是一种新的技术**.

1. 看Url就知道要什么资源
2. 看http method就知道针对资源干什
3. 看http status code就知道结果如何

对接口开发提供了一种可以广泛适用的规范，为前端后端交互减少了交流的成本，是**约定大于配置**的体现。

当然也不是所有的接口，都能用REST的形式来表述。要在实际工作中，灵活运用。我们用RESTful风格的目的是为大家提供统一标准，避免不必要的沟通成本的浪费，形成一种通用的风格。但也不是绝对适用任何场景。

#### 二、RESTful API的设计风格

##### 2.1、 RESTful是面向资源的（名词）

REST 通过 URI 暴露资源时，会强调不要在 URI 中出现动词。比如：

| 不符合REST的接口URI       | 符合REST接口URI       | 功能         |
| ------------------------- | --------------------- | ------------ |
| GET /api/getDogs/{id}     | GET /api/ dogs/{id)   | 获取一个小狗 |
| GET /api/getDogs          | GET /api/dogs         | 获取所有小狗 |
| GET /api/addDogs          | POST /api/ dogs       | 添加一个小狗 |
| GET /api/editDogs/{id}    | PUT /api/dogs/{id)    | 修改一个小狗 |
| GET /api/deleteDogs /{id} | DELETE /api/dogs/{id} | 删除一个小狗 |

##### 2.2、用HTTP方法体现对资源的操作（动词）

* GET：获取、读取资源
* POST：添加资源
* PUT：修改资源
* DELETE：删除资源

实际上，这四个动词实际上就对应着增删改查四个操作，利用了HTTP动词来表示对资源
的操作。

##### 2.3 HTTP状态码

通过HTTP状态码体现动作的结果，不要自定义
200 OK 400 Bad Request 500 Internal Server Error
在 APP 与 API 的交互当中，其结果逃不出这三种状态：

* 所有事情都按预期正确执行完毕- 成功
* APP 发生了一些错误 一 客户端错误（如：校验用户输入身份证，结果输入的是军官证，就是客户端输入错误）
* API发生了一些错误 一 服务器端错误（各种编码bug或服务内部自己导致的异常）

这三种状态与上面的状态码是一一对应的。如果你觉得这三种状态，分类处理结果太宽泛，http-status code还有很多。建议还是要遵循KISS(Keep It Stupid and Simple)原则，上面的三种状态码完全可以覆盖99％以上的场景。这三个状态码大家都记得住，而且非常常用，多
了就不一定了。

##### 2.4 Get方法和查询参数不应该改变数据

改变数据的事交给POST、PUT、 DELETE

##### 2.5 使用复数名词

/dogs 而不是 /dog

##### 2.6 复杂资源关系的表达

GET /cars/711/drivers/ 返回 使用过编号711汽车的所有司机
GET /cars/711/drivers/4 返回 使用过编号711汽车的4号司机

##### 2.7. 高级用法:HATEOAS

**HATEOAS**:Hypermedia as the Engine of Application State 超媒体作为应用状态的引擎.
RESTful API最好做到HATEOAS,即返回结果中提供链接,连向其他API方法,使得用户不查
文档,也知道下一步应该做什么.比如,当用户向api.example.com的根目录发出请求,会得
到这样一个文档.
{"link":{ "rel":"collection https://www.example.com/zoos","href":
"https://api.example.com/zoos","title": "List of zoos", "type":
"application/vnd.yourformat+json" }}
上面代码表示,文档中有一个link属性,用户读取这个属性就知道下一步该调用什么API或者可以调用什么API了.

##### 2.8 资源过滤、排序、选择和分页的表述

![1](D:\21级校企合作\上课笔记\03.10\1.png)

##### 2.9  版本化你的API

强制性增加API版本声明，不要发布无版本的APl。如：/api/v1/blog
面向扩展开放，面向修改关闭：也就是说一个版本的接口开发完成测试上线之后，我们一般不
会对接口进行修改，如果有新的需求就开发新的接口进行功能扩展。这样做的目的是：当你的新接口上线后，不会影响使用老接口的用户。如果新接口目的是替换老接口，也不要在v1版本原接口上修改，而是开发v2版本接口，并声明v1接口废弃！

三、参考
关于HTTP RESTful风格API设计的更多例子，请大家参考：http：//httpbin.org/



### 2.2 Spring常用注解及基础讲解

#### 一、HTTP协议的四种传参方式

| HTTP协议组成         | 协议内容示例                                   | 对应Spring注解 |
| -------------------- | ---------------------------------------------- | -------------- |
| path info传参        | /articles/12（查询id为12的文章，12是参数）     | @Path Variable |
| URL Query String传参 | /articles?id=12                                | @RequestParam  |
| Body 传参            | Content-Type: multipart/ formdata              | @RequestParam  |
| Body 传参            | Content-Type:application/json,或其他自定义格式 | @RequestBody   |
| Headers 传参         |                                                | @RequestHeader |

#### 二、常用注解回顾

##### 2.1 @RequestBody与 @ResponseBody

//注意并不要求@RequestBody与@ResponseBody成对使用.

```java
public @ResponseBody AjaxResponse saveArticle (@RequestBody ArticleV0 article)
```

如上代码所示：

* @RequestBody修饰请求参数，注解用于接收HTTP的body，默认是使用JSON的格式
* @ResponseBody修饰返回值，注解用于在HTTP的body中携带响应数据，默认是使用JSON的格式。如果不加该注解，spring响应字符串类型，是跳转到模板页面或jsp页面的开发模式。说
  白了：加上这个注解你开发的是一个数据接口，不加这个注解你开发的是一个页面跳转控制器。

![2](D:\21级校企合作\上课笔记\03.10\2.png)

在使用@ResponseBody注解之后程序不会再走视图解析器，也就不再做html视图渲染，而是直接
将对象以数据的形式（默认JSON)返回给请求发送者。那么我们有一个问题：如果我们想接收或
XML数据该怎么办？我们想响应excel的数据格式该怎么办？我们后文来回答这个问题。

##### 2.2. @RequestMapping注解

@RequestMapping注解是所有常用注解中,最有看点的一个注解,用于标注HTTP服务端点.它的很多属性对于丰富我们的应用开发方式方法,都有很重要的作用.如:

* value:应用请求端点,最核心的属性,用于标志请求处理方法的唯一性;
* method: HTTP协议的method类型,如:GET、 POST、 PUT、 DELETE等;
* consumes: HTTP协议请求内容的数据类型 (Content-Type) 例如application/json,text/html;
* produces: HTTP协议响应内容的数据类型.下文会详细讲解.
* params: HTTP请求中必须包含某些参数值的时候,才允许被注解标注的方法处理请求.
* headers: HTTP请求中必须包含某些指定的header值,才允许被注解标注的方法处理请求.

@RequestMapping(value = "/article", method = POST) @PostMapping(value = "/article")
上面代码中两种写法起到的是一样的效果,也就是PostMapping等同于@RequestMapping的method等于POST.同理:@GetMapping、 @PutMapping、 @DeleteMapping也都是简写的方式.

##### 2.3. @RestController与 @Controller

@Controller注解是开发中最常使用的注解,它的作用有两层含义:

* 一是告诉Spring,被该注解标注的类是一个Spring的Bean,需要被注入到Spring的上下文环境中.
* 二是该类里面所有被RequestMapping标注的注解都是HTTP服务端点.

@RestController相当于 @Controller和@ResponseBody结合.它有两层含义:

* 一是作为Controller的作用,将控制器类注入到Spring上下文环境,该类RequestMapping标注方法为HTTP服务端点.
* 二是作为ResponseBody的作用,请求响应默认使用的序列化方式是JSON,而不是跳转到jsp或模板页面.

##### 2.4. @PathVariable 与@RequestParam

PathVariable用于URl上的{参数},如下方法用于删除一篇文章,其中id为文章id.如:我们的请求URL为"/article/1",那么将匹配DeleteMapping并且PathVariable接收参数id=1.而RequestParam用于接收普通表单方式或者ajax模拟表单提交的参数数据.

```java
@DeleteMapping("/article/{id}")
public @ResponseBody AjaxResponse deleteArticle(@PathVariable Long id) {
}
@PostMapping("/article")
public @ResponseBody AjaxResponse deleteArticle (@RequestParam Long id) {}
```

#### 三、接收复杂嵌套对象参数

有的同学可能还无法理解RequestBody注解存在的真正意义，表单数据提交用RequestParam就好了，为什么还要搞出来一个RequestBody注解呢？

RequestBody注解的真正意义在于**能够使用对象或者嵌套对象接收前端数据**。

![3](D:\21级校企合作\上课笔记\03.10\3.png)

仔细看上面的代码，是一个paramData对象里面包含了一个bestFriend对象。这种数据结构使用RequestParam就无法接收了，RequestParam只能接收平面的、一对一的参数。

像这种嵌套的数据结构的参数，就需要我们在Java服务端定义两个类，一个类是ParamData，一个类是BestFriend。

```java
public class ParamData {
  private String name;
  private int id;
  private String phone;
  private BestFriend bestFriend;
  
  public static class BestFriend {
    private String address;
    private String gender;
  }
}
```

* 注意上面代码中省略了GET、SET方法等必要的Java plain model元素。

* 注意成员变量名称一定要和JSON属性名称对应上。

* 注意接收不同类型的参数，使用不同的成员变量类型

完成以上动作，我们就可以使用@RequestBody ParamData paramData，一次性的接收以上所有的复杂嵌套对象参数了，參数对象的所有属性都将被赋值。

#### 四、HTTP数据转换的原理

现在使用JSON已经比较普遍了，其方便易用、表达能力强，是绝大部分接口应用数据的首选。
那么如何响应其他类型的数据？其中的判别原理又是什么？

![4](D:\21级校企合作\上课笔记\03.10\4.png)

* 当一个HTTP请求到达时是一个InputStream，通过HttpMessageConverter转换为Java对象，从而进行参数接收。

* 当对一个HTTP请求进行响应时，我们首先输出的是一个java对象，然后由HttpMessageConverter转换为OutputStream输出。

当我们在Spring Boot应用中集成了jackson的类库之后，如下的一些HttpMessageConverter将会被加载。

| 实现类                               | 功能说明                                                     |
| ------------------------------------ | ------------------------------------------------------------ |
| StringHttpMessageConverter           | 将请求信息转为字符串                                         |
| FormHttpMessageConverter             | 将表单数据读取到MultiValueMap中                              |
| XmlAwareFormHttpMessageConverter     | 扩展与FormHttpMessageConverter，如果部分表单属性是XML数据，可用该转换器进行读取 |
| ResourceHttpMessageConverter         | 读写org.springframework.core.io.Resource对                   |
| BufferedimageHttpMessageConverter    | 读写Bufferedlmage对象                                        |
| ByteArrayHttpMessageConverter        | 读写二进制数据                                               |
| SourceHttpMessageConverter           | 读写java.xml.transform.Source类型的对象                      |
| MarshallingHttpMessageConverter      | 通过Spring的org.springframework，xml.Marshaller和Unmarshaller读写XML消息 |
| Jaxb2RootElementHttpMessageConverter | 通过JAXB2读写XML消息,将请求消息转换为标注的XmlRootElement和XmlType连接的类中 |
| RssChannelHttpMessageConverter       | 读写RSS种子消息                                              |
| AtomFeedHttpMessageConverter         | 和RssChannelHttpMessageConverter能够读写RSS种子消息          |

根据HTTP协议的Accept和Content-Type属性,以及参数数据类型来判别使用哪一种HttpMessageConverter.当使用RequestBody或ResponseBody时,再结合前端发送的Accept数据类型,会自动判定优先使用 MappinguacksonHttpMessageConverter作为数据转换器.但
是,不仅JSON可以表达对象数据类型,XML也可以.如果我们希望使用XML格式该怎么告知Spring呢,那就要使用到produces属性了.

```java
@GetMapping (va lue ="/demo",produces = MediaType.APPLICATION_ XML_VALUE)
```

这里我们明确的告知了返回的数据类型是xml，就会使用
Jaxb2RootElementHttpMessageConverter作为默认的数据转换器。当然实现XML数据响应比JSON还会更复杂一些，还需要结合@XmlRootElement、 @XmlElement等注解实体类来使用，同理
consumes屈性你也就会使用了。

五、自定义HttpMessageConverter
其实绝大多数的数据格式都不需要我们自定义HttpMessageConverter，都有第三方类库可以帮助
我们实现(包括下文代码中的Excel格式)。但有的时候，有些数据的输出格式并没有类似于Jackson
这种类库帮助我们处理，需要我们自定义数据格式。该怎么做？
下面我们就以Excel数据格式为例，写一个自定义的HTTP类型转换器。实现的效果就是，当我们返回AjaxPesponse这种数据类型，就自动将AjaxResponse转成Excel数据响应给客户端。

```xml
<dependency>
  <groupId>org. apache.poi</groupId>
  <artifactId>poi-ooxml</artifactId>
  <version>3.9</version>
</dependency>
```

```java
@Service
public class ResponseToXlsConverter extends
AbstractHttpMessageConverter<AjaxResponse> {
  
  private static final MediaType EXCEL_TYPE =
  NediaType.valueof("application/vnd.ms-excel");
  
  ResponseToXlsConverter() {
    Super(EXCEL_TYPE);
  }
  	
  @Override
  protected AjaxResponse readInternal(final Classx? extends<AjaxResponse> clazz,final HttpinputNessage inputNessage)throws IOException, HttpMessageNotReadableException {
    return null:
  ）
//针对AjaxResponse类型返回值,使用下面的writeInternal方法进行消息类型转换
  @Override
  protected booLean supports(final Class<?? c1azz) {
    return (AjaxResponse.class == clazz);
  ）
  @Override
  protected vaid writeInternal(final AjaxResponse ajaxResponse, final HttpOutputMessage outputNessage)throws IOException, HttpMessageNotWritableException {
  final Workbook workbook = new HSSFWorkbook();
  final Sheet sheet = workbook.createSheet();
  final Row row = sheet.createRow(0);
                row.createCell(0).setCellValue(ajaxResponse.getMessage());
                row.createCell(1).setCellValue(ajaxResponse.getData(). toString());
  workbook.write(outputMessage.getBody());
  }
}
```

* 实现AbstractHttpMessageConverter接口
* 指定该转换器是针对哪种数据格式的？如上文代码中的“application/vnd.ms-excel“
* 指定该转换器针对那些对象数据类型？如上文代码中的supports函数
* 使用writelnternal对数据进行输出处理，上例中是输出为Excel格式

### 2.3 使用注解开发RESTfu接口

#### 一、定义资源（对象）

```java
@Data
@ALLArgsConstructor
@NoArgsConstructor
@Builder
public class Article {
  private Long id;
  private String author;
  private String title;
  private String content;
  private Date createTime;
  private List<Reader> readerList;
}
```

```java
@Data
@Builder
@ALLArgsConstructor
@NoArgsConstructor
public class Reader implements Serializable {
  private String name:
  private Integer age;
}
```

Data、 Builder等都是lombok提供给我们的注解，有利于我们简化代码。

* @Builder为我们提供了通过对象属性的链式赋值构建对象的方法。
* @Data注解帮我们定义了一系列常用方法，如：getters、 setters、 hashcode、 equals等

#### 三、统一规范接口响应的数据格式

下面这个类是用于统一数据响应接口标准的。它的作用是：**统一所有开发人员响应前端请求的返回结果格式，减少前后端开发人员沟通成本，是一种RESTful接口标准化的开发约定**。
下面代码只对请求成功的情况进行封装，异常处理相关后续再做详细说明。

```java
@Data
public class AjaxResponse {
  private baolean isok; //请求是否处理成功
  private int code; //请求响应状态码 (200、 400、500)
  private String message;//请求结果描迷信息
  private Object data;//请求结果数据（通常用于查询操作）
  
  private AiaxResponse(){}
  
  //请求成功的响应,不带查询数据（用于用除、修改、新增接口）
  public static AjaxResponse success(){
    AjaxResponse ajaxResponse new AjaxResponse();
    ajaxResponse.setIsok(true);
    ajaxResponse.setCode(200);
    ajaxResponse.setMessage("请求的应成功!");
    return ajaxRespanse;
  }
  
  //请求成功的响应,带有查询数据（用于数据查询接口）
  public static AjaxResponse Success (Object obj){
    AjaxResponse ajaxResponse = new AjaxResponse();
    ajaxResponse.setIsok(true);
    ajaxResponse.setCode(200);
    ajaxResponse.setMessage("请求确应成功!);
    ajaxResponse.setData(obj);
    return ajaxRespanse;
  }
                             
  //请求成功的响应,带有查询数据（用于数据查询接口）
  public static AjaxRes ponse success (Object obj, String message){
    AjaxResponse ajaxResponse = new AjaxResponse();
    ajaxResponse.setIsok(true);
    ajaxResponse.setCode(200);
    ajaxResponse.setMessage (message);
    ajaxResponse.setData(obj);
    return ajaxResponse;
  }
}
```

#### 三、编写Controller

我们来实现几个简单的RESTful接口

* 增加一篇Article，使用POST方法
* 删除一篇Article，使用DELETE方法，參数是id
* 更新一篇Article，使用PUT方法，以id为主键进行更新
* 获取一篇Article，使用GET方法

下面代码中并未真正的进行数据库操作，后续结合Mybatis和JPA再做补充。

```java
package top.syhan.boot.restful.controller;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.bind.annotation.*;
import top.syhan.boot.restful.common.AjaxResponse;
import top.syhan.boot.restful.model.Article;
import top.syhan.boot.restful.model.Reader;

import java.util.Date;
import java.util.List;

/**
 * @program: boot-learning
 * @description:
 * @author: SYH
 * @create: 2022-03-10 16:30
 **/

@RestController
@Slf4j
@RequestMapping("/api/v1/articles")
public class ArticleController {

    /**
     * 获取一篇Article，使用GET方法,根据id查询一篇文章
     *
     * @param id id
     * @return AjaxResponse
     */
    @GetMapping("{id}")
    public AjaxResponse getArticle(@PathVariable("id") Long id) {
        List<Reader> readerList = List.of(Reader.builder().name("aaa").age(12).build(), Reader.builder().name("bbb").age(13).build());
        Article article = Article.builder()
                .id(id)
                .author("syhan")
                .content("SpringBoot 从青铜到王者")
                .title("SpringBoot")
                .readerList(readerList)
                .createTime(new Date()).build();
        log.info("article:" + article);
        return AjaxResponse.success(article);
    }

    @GetMapping()
    public AjaxResponse getArticleByParam(@RequestParam("idd") long id) {
        List<Reader> readerList = List.of(Reader.builder().name("aaa").age(12).build(), Reader.builder().name("bbb").age(13).build());
        Article article = Article.builder()
                .id(id)
                .author("syhan")
                .content("SpringBoot 从青铜到王者")
                .title("SpringBoot")
                .readerList(readerList)
                .createTime(new Date()).build();
        log.info("article:" + article);
        return AjaxResponse.success(article);
    }

    @GetMapping("all")
    public AjaxResponse selectAll() {
        List<Reader> readerList = List.of(Reader.builder().name("aaa").age(12).build(), Reader.builder().name("bbb").age(13).build());
        Article article = Article.builder()
                .id(111L)
                .author("syhan")
                .content("SpringBoot")
                .title("SpringBoot")
                .readerList(readerList)
                .createTime(new Date())
                .build();
        Article article2 = Article.builder()
                .id(222L)
                .author("syhan")
                .content("Java")
                .title("Java")
                .readerList(readerList)
                .createTime(new Date())
                .build();
        return AjaxResponse.success(List.of(article, article2));
    }
}
```

因为使用 了lombok的@Slf4j注解（类的定义处），就可以直按使用log变量打印日志。不需要写下面的这行代码.

```java
private static final Logger Log =
LoggerFactory.getLogger(HelloCantraller.class);
```

#### 四、 Postman测试

![p1](D:\21级校企合作\上课笔记\03.10\p1.png)

![p2](D:\21级校企合作\上课笔记\03.10\p2.png)

![p3](D:\21级校企合作\上课笔记\03.10\p3.png)

![p4](D:\21级校企合作\上课笔记\03.10\p4.png)

### 2.4 JSON数据处理与PostMan测试

#### 一、FastJSON、 Gson和Jackson对比

**开源的Jackson**：SpringBoot默认是使用Jackson作为JSON数据格式处理的类库，Jackson在各方面都比较优秀，所以不建议Jackson替换为Gson或fastjson。
**Google的Gson**：Gson是Google为满足内部需求开发的JSON数据处理类库，其核心结构非常简单，toJson与fromJson两个转换函数实现对象与JSON数据的转换，
阿里巴巴的FastJson：Fastjson是阿里巴巴开源的JSON数据处理类库，其主要特点是序列化速度快。当并发数据量越大的时候，越能体现出fastjson的优势。但选择JSON处理类库，快并不是唯一需要考虑的因素，与数据库或磁盘10相比，JSON数据序列化与反序列化的这点时间还不足以对软件性能产生比较大的影响。
**性能比较**：关于这三个类库的性能测试（截止2019年11月20日）总结如下：

* 序列化过程性能：fastjson >= jackson > Gson
* 反序列化性能：三者几乎不相上下。

**fastjson为人诟病的问题**：虽然fastjson速度上有一定的优势，但是其为了追求速度，很大程度放弃了JSON的规范性。因此时不时在有些版本中暴露安全问题。所以用不用fastjson在国内软件界还是有争议的，在国外基本没人用。

#### 二、在Spring中注解方法使用Jackson

不建议将Jackson替换为Gson或fastjson。Jackson主要的作用是：

> 什么叫序列化与反序列化？说白了就是把对象转成可传输、可存储的格式（json、xml、二进制、甚至自定义格式）叫做序列化。反序列化顾名思义。

* 反序列化：在客户端将请求数据上传到服务端的时候，自动的处理JSON数据对象中的字符串、数字，将其转换为包含Date类型、Integer等类型的对象。

* 序列化：按照指定的格式、顺序等将实体类对象转换为JSON字符串

所以下面就介绍一下Jackson的常用注解的使用方法,帮助我们进行序列化和反序列化工作.

**常用注解**
这些注解通常用于标注Java实体类或实体类的属性.

* @JsonPropertyOrder(value=("pname1","pname2"})改变子属性在JSON序列化中的默认定义的顺序.如:param1 在先,param2在后.
* @Jsonlgnore 加在属性上面,排除某个属性不做序列化与反序列化
* @JsonlgnoreProperties(ignoreUnknown = true),将这个注解写在类上之后,就会忽略JSON字符串中存在,但实体类不存在的属性,不予赋值,也不会出现异常.
* @JsonlgnoreProperties({ "xxx","yyyy"})忽略某些属性不进行序列化
* @JsonProperty(anotherName) 为某个属性换一个名称,体现在JSON数据里面
* @Jsonlnclude(Jsonlnclude.Include.NON_ NULL) 排除为空的元素不做序列化反序列化
* @UsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8"） 指定日期类型的属性格式

```java
@JsonPropertyOrder(value={"content"," title"})
public class Article {
  
  @JsonIgnore
  private Long id;
  
  @JsonProperty("auther")
  private String author;
  
  private String title;
  private String content;
  
  @JsonInclude( JsonInclude. Include. NON_NULL)
  @JsonFormat(pattern = "yyyy-MM-dd HH:mm:Ss", timezone = "GMT+8"）
  private Date createTime;
              
  private List<Reader> reader;
}
```

上文代码中对应的JSON数据格式可以为：

```json
{
  auther: "",
  content: "",
  title: "",
  createTime:"2022-03-10 12:12:12",
  reader: [{"name": "zhangsan","age": 22},{"name":"lisi" ,"age" : 23}]
}
```

* 因为定义了 JsonPropertyOrder，content在先，title在后
* 因为定义了Jsonlgnore，id属性被忽略
* 因为定义了JsonProperty，author属性变为auther
* 因为定义了Jsonlnclude和JsonFormat， createTime不要为空，并且格式为“yyyy-MM-dd HH：mm：ss"

通常会对日期类型转换进行全局配置，而不是在每一个Java bean里面配置

```yaml
spring:
  jackson:
    date-format: yyyy-MM-dd HH:mm:SS
    time-zone: GMT+8
```

#### 三、手动数据转换

除了在Spring框架内实现自动的前后端JSON数据与Java对象的转换，我们还可以使用Jackson自己写代码进行转换。

```java
//jackson的ObjectMapper 转换对象
ObjectMapper mapper = new ObjectMapper()；
//将某个java对象转换为JSON字符串
String jsonstr = mapper.writeValueAsString (javaObj)；
//将jsonstr转换为Demo类的对象
Demo demo = mapper.readValue(jsonStr， Demo.class)；
```

当JSON字符串代表的对象的字段多于类定义的字段时,使用readValue会抛出UnrecognizedPropertyException异常.

在类的定义处加上**@JsonlgnoreProperties(ignoreUnknown = true)**可以解决这个问题.

#### 四、Jackson全局配置

在Spring框架内使用Jackson的时候，通常需要一些特殊的全局配置，来应对我们JSON序列化与反序列化中出现的各种问题。
Spring Boot 提供了两种配置方式，一是配置文件的方式

```yaml
spring：
  jackson：
  #日期类型格式化
    date-format： yyyy-MM-dd HH：mm：ss
    serialization：
    #格式化输出，通常为了节省网络流量设置为false。因为格式化之后会带有缩进，方便阅读。
    indent_output：false
    #某些类对象无法序列化的时候，是否报错
    fail_on_empty_beans：false
  #设置空如何序列化，见下文代码方式详解
  defaultPropertyInclusion：NON_ EMPTY
  deserialization：
    ＃json对象中有不存在的属性时候，是否报错
    fail_on_unknown_properties：false
  parser：
    #允许出现特殊字符和转义符
    allow_unquoted_control_chars：true
    #允许出现单引号
    aLlow_single_quotes：true
```

二是通过代码的方式，方式一更容易，方式二更灵活。
方式一无法解决的问题，可以尝试使用方式二。

```java
@Bean
@Primary
@ConditionalOnMissingBean(ObjectNapper.class)
public ObjectMapper jacksonObjectMapper( JacksonObjectHapperBuilder builder)
{
  ObjectMapper objectNapper = 
  builder.createXm WMapper(false).build();
  //通过该方法对mapper对象进行设置,所有序列化的对象都将按改规则进行系列化
  // Include.Include.ALWAYS 默认
  // Include.NON_DEFAULT 屬性为默认值不序列化
  // Include.NON_EMPTY 果性为 空（"） 或者为 NULL 都不序列化,则返回的json是没有这个字段的.这样对移动端会更省流量
  // Include.NON_ NULL 属性为NULL 不序列化
  obiectMapper.setSerializationInclusion (JsonInc Lude.Include.NON_EMPTY);
  objectwapper.configure(DeserializationFeature. FAIL_ON_UNKNOMN _ PROPERTIES, false);
  // 允许出现特殊字符和转义符
  obiectMapper.configure(JsonParser.Feature.ALLOM_UNOUOTED_CONTROL_ CHARS,true):
  // 允许出现单引号
  obiectMapper.configure(JsonParser.Feature.ALLOW_ SINGLE_QUOTES,true);
// 字段保留,将nul1值转为""
obiectMapper.qetSerializerProvider().setNulLValueSerializer(new JsonSerializers0bject>()                                                           {
    @Override
    public void serialize(Object o, JsonGenerator jsonGenerator,SerializerPravider serializerProvider)
    throws IOException {
      jsonGenerator.writeString("");
    }
  });
  return objectNapper;
}
```



### 2.5 使用Mockito编码完成接口测试

之前我们都是使用Postman来进行接口测试的，本节我们来使用编码的方式来进行接口测试。

#### 一、编码实现接口测试

1. ##### 为什么要写代码做测试

因为在做系统自动化持续集成的时候，会要求自动做单元测试，只有所有的单元测试都跑通了，才能打包构建。比如：使用maven在打包之前将所有的测试用例执行一遍。这里重点是自动化，所以Postman这种工具很难插入到持续集成的自动化流程中去。

2. ##### JUnit测试框架

我们先回顾一下JUnit常用的测试注解，在JUnit4和JUnit5中，注解的写法有些变化。

| junit4                       | junit5                              | 特点                                               |
| ---------------------------- | ----------------------------------- | -------------------------------------------------- |
| @Test                        | @Test                               | 声明一个测试方法                                   |
| @ BeforeClass                | @BeforeAll                          | 在当前类的所有测试方法之前执行。注解在[静态方法]   |
| @AfterClass                  | @AfterAll                           | 在当前类中的所有测试方法之后执行。注解在[静态方法] |
| @Before                      | @BeforeEach                         | 在每个测试方法之前执行。注解在[非静态方法]上       |
| @After                       | @AfterEach                          | 在每个测试方法之后执行。注解在[非静态方法]         |
| @RunWith(SpringRunner.class) | @ExtendWith (SpringExtension.class) | 类class定义上                                      |

3. Mockito测试框架

Mockito是GitHub上使用最广泛的Mock框架，可以与JUnit结合使用。
Mockito框架可以创建和配置mock对象，使用Mockito简化了具有外部依赖的类的测试开发。
Mockito测试框架可以帮助我们模拟HTTP请求，从而达到在服务端测试目的。
因为其不会真的发送HTTP请求，只是模拟，从而节省了HTTP请求的网络传输，测试速度更快。

确认一下模块依赖

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-test</artifactId>
  <scope>test</scope>
  <exclusians>
    <exclusion>
      <groupId>org.junit.vintage</groupid>
      <artifactId>junit-vintage-engine</artifactId>
    </exclusian>
  </exclusions>
</dependency>
```

spring-boot-starter-test自动包含Junit 5 和Mockito框架，以下测试代码是基于Junit5的。

![10](D:\21级校企合作\上课笔记\03.10\10.png)

MockMvc对象有以下几个基本的方法：

* perform：模拟执行一个RequestBuilder构建的HTTP请求，会执行SpringMVC的流程并映射到相应的控制器Controller执行。
* contentType：发送请求内容的序列化的格,“application/json“表示JSON数据格式
* andExpect：添，加RequsetMatcher验证规则，验证控制器执行完成后结果是否正确，或者说是结果是否与我们期望(Expect）的一致。
* andDo： 添加ResultHandler结果处理器，比如调试时打印结果到控制台
* andReturn：最后返回相应的MvcResult，然后进行自定义验证/进行下一步的异步处理

上面的整个过程，我们都没有使用到Spring Context依赖注入、也没有启动tomcat web容器。整个测试过程十分轻量级，速度很快。

**测试注意**
**因为没有用到Spring，所以在application。yml中的时间格式化全局配置无效，别忘了在Article实体类加上**



#### 二、真实Servlet容器环境下的测试

上面的测试执行速度非常快，但是有一个问题：它没有启动Servlet容器和Spring 上下文，自然也就无法实现依赖注入（不支持@Resource和@Autowired注解），这就导致它在从控制层到持久层全流程测试中有很大的局限性。

![5](D:\21级校企合作\上课笔记\03.10\5.png)

换一种写法：看看有没有什么区别。
在测试类上面加上这样两个注解，并且mockMvc对象使用@Resource自动注入，删掉BeforeAll注解。



启动测试，看看和之前有没有什么区别？



看到上面这个截图，是不是已经明白了？
该测试方法真实的启动了一个Tomcat容器、以及Spring 上下文，所以我们可以进行依赖注入(@Resource)，测试实现的效果和使用MockMvcBuilders构建MockMVC对象的效果是一样的，但是有一个非常明显的缺点：每次做一个接口测试，都会真实启动一次Servlet容器和Spring上下文，加载项目里定义的所有的Bean，导致执行过程会比较缓慢。

1. ##### @Spring BootTest 注解

是用来创建Spring的上下文ApplicationContext，保证测试在上下文环境里运行。单独使用@SpringBootTest不会启动servlet容器。所以**只是使用SpringBootTest 注解，不可以使用@Resource和@Autowired等注解进行bean的依赖注入**。（准确的说是可以使用，但被注解的bean为null)）

2. ##### @ExtendWith(@RunWith注解）

* RunWith方法为我们构造了一个的Servlet容器运行运行环境，并在此环境下测试。然而为什么要构建servlet容器？因为使用了依赖注入，注入了MockMvc对象，而在上一个例子里面是我们
  自己new的。

* 而@AutoConfigureMockMvc注解，该注解表示mockMvc对象由spring 依赖注入构建，你只负责使用就可以了。这种写法是为了让测试在servlet容器环境下执行。

简单地说:**如果你单元测试代码使用了"依赖注入@Resource"就必须加上@ExtendWith,如果你不是手动new MockMvc对象就加上@AutoConfigureMockMvc**

实际上@Spring BootTest 注解已经包含了 @Extendwith注解，如果使用了前者，也可以忽略后者。





#### 三、轻量级测试

在ExtendWith的AutoConfigureMockMvc注解的共同作用下，启动了SpringMvC的运行容器，并且把项目中所有的@Bean全部都注入进来。把所有的bean都注入进来是不是很臃肿？这样会拖慢单元测试的效率。如果我只是想测试一下控制层Controller，怎么办？或者说我只想具体到测试一下ArticleRestController，怎么办？要把应用中所有的bean都注入么？有没有轻量级的解决方案？一定是有的。

````java
@AutoConfigureMockMvc
@ExtendWith(SpringExtension.class)
@WebMvcTest(ArticleController.class)
````



**使用@WebMvcTest替换@SpringBootTest**

* @SpringBootTest注解告诉Spring Boot去寻找一个主配置类(例如带有@Spring BootApplication的配置类),并使用它来启动Spring应用程序上下文.SpringBootTest加载完整的应用程序并注入所有可能的bean,因此速度会很慢.
* @WebMvcTest注解主要用于controller层测试,只覆盖应用程序的controller层@WebMvcTest(ArticleController.class)只加载ArticleController这一个Bean用作测试.所以
  WebMvcTest要快得多,因为我们只加载了应用程序的一小部分.

#### 四、MockMvc更多的用法总结

```java
//模拟GET请求:
mockMvc.perform(MockMvcRequestBuilders.get("/user/{id}", userId));

//模拟Post请求:
mockMvc.perform(MockMvcRequestBuilders.post("url", parameters));

//模拟文件上传:
mockMvc.perform(MockMvcRequestBuilders.multipart("url").file("fileName","file".getBytes("UTF-8")));

//模拟session和cookie:
mockMvc.perform (MockMvcRequestBuilders.get ("url").sessionAttr("name", "value"));
mockMvc.perform (MockMvcRequestBuilders.get ("url").cookie(new Cookie("name", "value")));

//设置HTTP Header:
mockMyc.perform (MockMvcRequestBuilders
.get("url", parameters)
.contentType ("application/x-www-form-urlencoded")
.accept ("application/json")
.header("","""));
```



### 2.6 Swagger3即OpenAPl使用

#### 一、为什么要发布API接口文档

现在很多公司都采取前后端分离的开发模式，前端和后端的工作由不同的工程师完成。在这种开发模式下，维护一份及时更新且完整的API文档将会极大的提高我们的工作效率。
Swagger 给我们提供了一个全新的维护 API 文档的方式，下面我们来了解一下它的优点：

* 代码变，文档变。只需要少量的注解，Swagger 就可以根据代码自动生成 API 文档，很好的保证了文档的时效性。
* 跨语言性，支持40 多种语言。
* Swagger UI 呈现出来的是一份可交互式的 API 文档，我们可以直接在文档页面尝试 API 的调用，省去了准备复杂的调用参数的过程。
* 还可以将文档规范导入相关的工具（例如 Soapul)，这些工具将会为我们自动地创建自动化测试。

#### 二、背景及名词解释

* OpenAPl是规范的正式名称。规范的开发工作于2015年启动，当时SmartBear（负责Swagger工具开发的公司）将Swagger 2.0规范捐赠给了Open API Initiative，该协会由来自技术领域不同领域的30多个组织组成。此后，该规范被重命名为**OpenAPI规范**。

* **Swagger**

  * 是一个 API文档维护组织，后来成为了 Open APl 标准的主要定义者。现在最新的版本为17年发布的 Swagger3 (Open Api3)
  * 是一个Open APl规范实现工具包，由于Swagger工具是由参与创建原始Swagger规范的团队开发的，因此通常仍将这些工具视为该规范的代名词。目前可以认为Swagger3就是Open APl3.0。

* OpenAPl 3.0： 2017年7月，Open APl Initiative最终发布了OpenAPl Specification 3.0.0。它对2.0规范进行了很多改进。Open AP1 3.0规范可以用JSON或YAML编写，并且在记录RESTful API方面做得很好。同时标志着Swagger2成为过去式。

* SpringFox是 spring 社区维护的一个项目（非官方)，帮助使用者将 swagger2 集成到Spring 中。常常用于 Spring 中帮助开发者生成文档，并可以轻松的在Spring Boot中使用。截
  至2020年4月，尚未支持 OpenAPI3 标准。

* SpringDoc也是 spring 社区维护的一个项目（非官方），帮助使用者将 swagger3 集成到Spring 中。

  也是用来在 Spring 中帮助开发者生成文档，并可以轻松的在Spring Boot中使用。

##### 三、整合springdoc-openapi

添加openapi依赖

```xml
<dependency>
<groupId>org.springdoc</graupld>
<artifactId>springdoc-openapi-ui</artifactid>
<version>1.6.6</version>
</dependency>
```

就这么简单，文档就构建完成了，不需要做任何的其他配置。
集成完成之后，启动服务，浏览器输入：http：//localhost：8080/swagger-ui.html

![6](D:\21级校企合作\上课笔记\03.10\6.png)





#### 四、将API分组分组展示

配置方法

新建一个HelloController配合

重启服务，可以通过下拉选择分组查看组内API：

![7](D:\21级校企合作\上课笔记\03.10\7.png)

![8](D:\21级校企合作\上课笔记\03.10\8.png)

#### 五、使用OpenAPl测试

![9](D:\21级校企合作\上课笔记\03.10\9.png)